import{r as o,i as u}from"./index-9bc05931.js";import{a as I,b as l,u as p}from"./useDragDropManager-6429935c.js";function m(r,e,t){const[n,i]=I(r,e,t);return l(function(){const a=r.getHandlerId();if(a!=null)return r.subscribeToStateChange(i,{handlerIds:[a]})},[r,i]),n}function P(r,e,t){return m(e,r||(()=>({})),()=>t.reconnect())}function O(r,e){const t=[...e||[]];return e==null&&typeof r!="function"&&t.push(r),o.useMemo(()=>typeof r=="function"?r():r,t)}function y(r){return o.useMemo(()=>r.hooks.dragSource(),[r])}function b(r){return o.useMemo(()=>r.hooks.dragPreview(),[r])}let h=!1,f=!1;class M{receiveHandlerId(e){this.sourceId=e}getHandlerId(){return this.sourceId}canDrag(){u(!h,"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return h=!0,this.internalMonitor.canDragSource(this.sourceId)}finally{h=!1}}isDragging(){if(!this.sourceId)return!1;u(!f,"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return f=!0,this.internalMonitor.isDraggingSource(this.sourceId)}finally{f=!1}}subscribeToStateChange(e,t){return this.internalMonitor.subscribeToStateChange(e,t)}isDraggingSource(e){return this.internalMonitor.isDraggingSource(e)}isOverTarget(e,t){return this.internalMonitor.isOverTarget(e,t)}getTargetIds(){return this.internalMonitor.getTargetIds()}isSourcePublic(){return this.internalMonitor.isSourcePublic()}getSourceId(){return this.internalMonitor.getSourceId()}subscribeToOffsetChange(e){return this.internalMonitor.subscribeToOffsetChange(e)}canDragSource(e){return this.internalMonitor.canDragSource(e)}canDropOnTarget(e){return this.internalMonitor.canDropOnTarget(e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.sourceId=null,this.internalMonitor=e.getMonitor()}}function L(r,e,t){const n=t.getRegistry(),i=n.addTarget(r,e);return[i,()=>n.removeTarget(i)]}function R(r,e,t){const n=t.getRegistry(),i=n.addSource(r,e);return[i,()=>n.removeSource(i)]}function v(r,e,t,n){let i=t?t.call(n,r,e):void 0;if(i!==void 0)return!!i;if(r===e)return!0;if(typeof r!="object"||!r||typeof e!="object"||!e)return!1;const s=Object.keys(r),a=Object.keys(e);if(s.length!==a.length)return!1;const d=Object.prototype.hasOwnProperty.bind(e);for(let c=0;c<s.length;c++){const g=s[c];if(!d(g))return!1;const D=r[g],S=e[g];if(i=t?t.call(n,D,S,g):void 0,i===!1||i===void 0&&D!==S)return!1}return!0}function w(r){return r!==null&&typeof r=="object"&&Object.prototype.hasOwnProperty.call(r,"current")}function T(r){if(typeof r.type=="string")return;const e=r.type.displayName||r.type.name||"the component";throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${e} into a <div>, or turn it into a drag source or a drop target itself.`)}function H(r){return(e=null,t=null)=>{if(!o.isValidElement(e)){const s=e;return r(s,t),s}const n=e;return T(n),E(n,t?s=>r(s,t):r)}}function k(r){const e={};return Object.keys(r).forEach(t=>{const n=r[t];if(t.endsWith("Ref"))e[t]=r[t];else{const i=H(n);e[t]=()=>i}}),e}function C(r,e){typeof r=="function"?r(e):r.current=e}function E(r,e){const t=r.ref;return u(typeof t!="string","Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"),t?o.cloneElement(r,{ref:n=>{C(t,n),C(e,n)}}):o.cloneElement(r,{ref:e})}class U{receiveHandlerId(e){this.handlerId!==e&&(this.handlerId=e,this.reconnect())}get connectTarget(){return this.dragSource}get dragSourceOptions(){return this.dragSourceOptionsInternal}set dragSourceOptions(e){this.dragSourceOptionsInternal=e}get dragPreviewOptions(){return this.dragPreviewOptionsInternal}set dragPreviewOptions(e){this.dragPreviewOptionsInternal=e}reconnect(){const e=this.reconnectDragSource();this.reconnectDragPreview(e)}reconnectDragSource(){const e=this.dragSource,t=this.didHandlerIdChange()||this.didConnectedDragSourceChange()||this.didDragSourceOptionsChange();return t&&this.disconnectDragSource(),this.handlerId?e?(t&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragSource=e,this.lastConnectedDragSourceOptions=this.dragSourceOptions,this.dragSourceUnsubscribe=this.backend.connectDragSource(this.handlerId,e,this.dragSourceOptions)),t):(this.lastConnectedDragSource=e,t):t}reconnectDragPreview(e=!1){const t=this.dragPreview,n=e||this.didHandlerIdChange()||this.didConnectedDragPreviewChange()||this.didDragPreviewOptionsChange();if(n&&this.disconnectDragPreview(),!!this.handlerId){if(!t){this.lastConnectedDragPreview=t;return}n&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragPreview=t,this.lastConnectedDragPreviewOptions=this.dragPreviewOptions,this.dragPreviewUnsubscribe=this.backend.connectDragPreview(this.handlerId,t,this.dragPreviewOptions))}}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didConnectedDragSourceChange(){return this.lastConnectedDragSource!==this.dragSource}didConnectedDragPreviewChange(){return this.lastConnectedDragPreview!==this.dragPreview}didDragSourceOptionsChange(){return!v(this.lastConnectedDragSourceOptions,this.dragSourceOptions)}didDragPreviewOptionsChange(){return!v(this.lastConnectedDragPreviewOptions,this.dragPreviewOptions)}disconnectDragSource(){this.dragSourceUnsubscribe&&(this.dragSourceUnsubscribe(),this.dragSourceUnsubscribe=void 0)}disconnectDragPreview(){this.dragPreviewUnsubscribe&&(this.dragPreviewUnsubscribe(),this.dragPreviewUnsubscribe=void 0,this.dragPreviewNode=null,this.dragPreviewRef=null)}get dragSource(){return this.dragSourceNode||this.dragSourceRef&&this.dragSourceRef.current}get dragPreview(){return this.dragPreviewNode||this.dragPreviewRef&&this.dragPreviewRef.current}clearDragSource(){this.dragSourceNode=null,this.dragSourceRef=null}clearDragPreview(){this.dragPreviewNode=null,this.dragPreviewRef=null}constructor(e){this.hooks=k({dragSource:(t,n)=>{this.clearDragSource(),this.dragSourceOptions=n||null,w(t)?this.dragSourceRef=t:this.dragSourceNode=t,this.reconnectDragSource()},dragPreview:(t,n)=>{this.clearDragPreview(),this.dragPreviewOptions=n||null,w(t)?this.dragPreviewRef=t:this.dragPreviewNode=t,this.reconnectDragPreview()}}),this.handlerId=null,this.dragSourceRef=null,this.dragSourceOptionsInternal=null,this.dragPreviewRef=null,this.dragPreviewOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDragSource=null,this.lastConnectedDragSourceOptions=null,this.lastConnectedDragPreview=null,this.lastConnectedDragPreviewOptions=null,this.backend=e}}function N(r,e){const t=p(),n=o.useMemo(()=>new U(t.getBackend()),[t]);return l(()=>(n.dragSourceOptions=r||null,n.reconnect(),()=>n.disconnectDragSource()),[n,r]),l(()=>(n.dragPreviewOptions=e||null,n.reconnect(),()=>n.disconnectDragPreview()),[n,e]),n}function x(){const r=p();return o.useMemo(()=>new M(r),[r])}class F{beginDrag(){const e=this.spec,t=this.monitor;let n=null;return typeof e.item=="object"?n=e.item:typeof e.item=="function"?n=e.item(t):n={},n??null}canDrag(){const e=this.spec,t=this.monitor;return typeof e.canDrag=="boolean"?e.canDrag:typeof e.canDrag=="function"?e.canDrag(t):!0}isDragging(e,t){const n=this.spec,i=this.monitor,{isDragging:s}=n;return s?s(i):t===e.getSourceId()}endDrag(){const e=this.spec,t=this.monitor,n=this.connector,{end:i}=e;i&&i(t.getItem(),t),n.reconnect()}constructor(e,t,n){this.spec=e,this.monitor=t,this.connector=n}}function W(r,e,t){const n=o.useMemo(()=>new F(r,e,t),[e,t]);return o.useEffect(()=>{n.spec=r},[r]),n}function Y(r){return o.useMemo(()=>{const e=r.type;return u(e!=null,"spec.type must be defined"),e},[r])}function q(r,e,t){const n=p(),i=W(r,e,t),s=Y(r);l(function(){if(s!=null){const[d,c]=R(s,i,n);return e.receiveHandlerId(d),t.receiveHandlerId(d),c}},[n,e,t,i,s])}function V(r,e){const t=O(r,e);u(!t.begin,"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");const n=x(),i=N(t.options,t.previewOptions);return q(t,n,i),[P(t.collect,n,i),y(i),b(i)]}const $={WORKER:"worker"};export{$ as I,P as a,V as b,w as i,L as r,v as s,O as u,k as w};
